<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyMIND: Multimodal Integrated Neurocritical Data</title>
  <link rel="stylesheet" href="py_style.css" />
</head>
<body>
  <header>
    <h1>pyMIND</h1>
    <h2>Multimodal Integrated Neurocritical Data — v.Beta</h2>
  </header>

  <main>
    <!-- Sidebar: now persistent with dynamic "Back" labels -->
    <aside class="sidebar">
      <button class="btn connect" id="connectBtn">Connect</button>
      <button class="btn visualize" id="visualizeBtn">Visualize</button>
      <button class="btn disconnect" id="disconnectBtn">Disconnect</button>
      <div class="brown-logo">
        <img src="logo.png" alt="Brown University Logo">
      </div>
    </aside>

    <!-- Main Menu Placeholder -->
    <section id="mainPanel" class="main-panel active">
      <div class="welcome-container">
        <p>Select a mode to begin.</p>
      </div>
    </section>

    <!-- Connect Screen -->
    <section id="connectPanel" class="main-panel hidden">
      <div class="directory-select">
        <label for="saveDir">Please choose a save directory</label>
        <input type="text" id="saveDir" placeholder="Save Directory Location..." />
        <button class="browse">...</button>
      </div>

      <div class="modules">
        <div class="module">
          <h3>EEG</h3>
          <select><option>BrainVision acti</option></select>
          <select><option>TCP/IP</option></select>
          <select><option>HDF5</option></select>
          <button class="btn-small">Connect</button>
        </div>

        <div class="module">
          <h3>Vitals</h3>
          <select><option>Philips Intellivue</option></select>
          <select><option>Serial</option></select>
          <select><option>HDF5</option></select>
          <label class="waveform-label">Request Waveforms (5 Max)</label>
          <div class="waveform-list">
            <ul>
              <li>Arterial Blood Pressure (ABP)</li>
              <li>PLETH wave label</li>
              <li>Impedance RESP wave</li>
              <li>ECG Lead I</li>
              <li>ECG Lead II</li>
              <li>ECG Lead III</li>
              <li>ECG Lead AVR</li>
              <li>Intracranial Pressure (ICP)</li>
              <li>Intracranial Pressure 2 (IC2)</li>
            </ul>
          </div>
          <button class="btn-small">Connect</button>
        </div>

        <div class="module disabled">
          <h3>NIRS</h3>
          <p>Coming Soon</p>
        </div>
      </div>
    </section>

    <!-- Visualize Screen -->
    <section id="visualizePanel" class="main-panel hidden">
      <div class="tab-buttons">
        <button class="tab active">Real Time</button>
        <button class="tab">Trends</button>
        <button class="tab" id="showGraphsBtn">Test Graphs</button>
      </div>

      <div class="directory-select">
        <input type="text" placeholder="Save Directory Location..." />
        <button class="browse">...</button>
      </div>

      <div class="file-upload-section">
        <div class="file-upload-group">
          <label for="eegFile">EEG HDF5 File:</label>
          <input type="file" id="eegFile" accept=".hdf5,.h5" />
          <button class="btn-small" id="uploadEEG">Upload</button>
          <span id="eegStatus" class="upload-status"></span>
        </div>
        <div class="file-upload-group">
          <label for="vitalsWavesFile">Vitals Waves HDF5 File:</label>
          <input type="file" id="vitalsWavesFile" accept=".hdf5,.h5" />
          <button class="btn-small" id="uploadVitalsWaves">Upload</button>
          <span id="vitalsWavesStatus" class="upload-status"></span>
        </div>
        <div class="file-upload-group">
          <label for="vitalsNumericsFile">Vitals Numerics HDF5 File:</label>
          <input type="file" id="vitalsNumericsFile" accept=".hdf5,.h5" />
          <button class="btn-small" id="uploadVitalsNumerics">Upload</button>
          <span id="vitalsNumericsStatus" class="upload-status"></span>
        </div>
      </div>

      <div class="visualize-layout">
        <!-- Left side: Graphs -->
        <div class="visualize-panels">
          <div class="panel">
            <h3>EEG Trends</h3>
            <div class="monitor-container" id="eegBox">
              <canvas id="eegCanvas"></canvas>
              <div class="monitor-loading" id="eegLoading">Select files to view...</div>
            </div>
            <div class="btn-group">
              <button class="btn-small" id="eegRawTracesBtn">Raw Traces</button>
              <button class="btn-small" id="eegSpectrogramBtn">Spectrogram</button>
              <button class="btn-small" id="clearEEGBtn">Clear</button>
            </div>
          </div>

          <!-- EEG Spectrogram Panel (hidden by default) -->
          <div class="panel" id="spectrogramPanel" style="display: none;">
            <h3>EEG Spectrograms <button class="btn-small" id="closeSpectrogramBtn">× Close</button></h3>
            <div class="spectrogram-grid" id="spectrogramGrid">
              <div class="monitor-loading" id="spectrogramLoading">Loading spectrograms...</div>
            </div>
          </div>

          <div class="panel">
            <h3>Vitals Waveforms</h3>
            <div class="monitor-container" id="vitalsBox">
              <canvas id="vitalsCanvas"></canvas>
              <div class="monitor-loading" id="vitalsLoading">Select files to view...</div>
            </div>
            <div class="btn-group">
              <button class="btn-small">Raw Traces</button>
              <button class="btn-small" id="clearVitalsWavesBtn">Clear</button>
            </div>
          </div>

          <div class="panel">
            <h3>Vitals Trends</h3>
            <div class="monitor-container" id="vitalsTrendsBox">
              <canvas id="vitalsTrendsCanvas"></canvas>
              <div class="monitor-loading" id="vitalsTrendsLoading">Select files to view...</div>
            </div>
            <div class="btn-group">
              <button class="btn-small">Trends</button>
              <button class="btn-small" id="clearVitalsNumericsBtn">Clear</button>
            </div>
          </div>
        </div>

        <!-- Right side: Features sidebar -->
        <div class="features-sidebar">
          <!-- Threshold Tracking Panel -->
          <div class="threshold-panel">
            <h3>Threshold Monitoring</h3>
            <div class="threshold-status" id="thresholdStatus">
              <div class="status-message">Upload vitals numerics to enable</div>
            </div>
            <div class="threshold-items" id="thresholdItems">
              <!-- HR -->
              <div class="threshold-item" data-param="hr">
                <div class="threshold-header">
                  <span class="threshold-label">HR</span>
                  <span class="threshold-value" id="hrValue">--</span>
                  <span class="threshold-unit">bpm</span>
                  <span class="threshold-indicator" id="hrIndicator"></span>
                </div>
                <div class="threshold-inputs">
                  <input type="number" id="hrMin" placeholder="Min" value="60" />
                  <span class="threshold-separator">-</span>
                  <input type="number" id="hrMax" placeholder="Max" value="100" />
                </div>
              </div>
              <!-- SpO2 -->
              <div class="threshold-item" data-param="spo2">
                <div class="threshold-header">
                  <span class="threshold-label">SpO2</span>
                  <span class="threshold-value" id="spo2Value">--</span>
                  <span class="threshold-unit">%</span>
                  <span class="threshold-indicator" id="spo2Indicator"></span>
                </div>
                <div class="threshold-inputs">
                  <input type="number" id="spo2Min" placeholder="Min" value="92" />
                  <span class="threshold-separator">-</span>
                  <input type="number" id="spo2Max" placeholder="Max" value="100" />
                </div>
              </div>
              <!-- MAP -->
              <div class="threshold-item" data-param="map">
                <div class="threshold-header">
                  <span class="threshold-label">MAP</span>
                  <span class="threshold-value" id="mapValue">--</span>
                  <span class="threshold-unit">mmHg</span>
                  <span class="threshold-indicator" id="mapIndicator"></span>
                </div>
                <div class="threshold-inputs">
                  <input type="number" id="mapMin" placeholder="Min" value="70" />
                  <span class="threshold-separator">-</span>
                  <input type="number" id="mapMax" placeholder="Max" value="105" />
                </div>
              </div>
            </div>
            <div class="threshold-actions">
              <label class="threshold-toggle">
                <input type="checkbox" id="autoAnnotateBreaches" />
                <span>Auto-annotate breaches</span>
              </label>
            </div>
          </div>

          <!-- Annotations Panel -->
          <div class="timestamp-table">
            <h3>Annotations</h3>
            <div class="table-header">
              <span>Time</span>
              <span>Description</span>
              <span></span>
            </div>
            <div class="table-body" id="timestampTableBody"></div>
            <div class="timestamp-input-row">
              <input type="number" id="timestampTimeInput" placeholder="0.0" step="0.1" min="0" />
              <input type="text" id="timestampDescInput" placeholder="Description..." maxlength="100" />
              <button class="btn-small" id="addTimestampBtn">+</button>
            </div>
            <div class="table-actions">
              <button class="btn-small" id="markCurrentTimeBtn">Mark Current</button>
              <button class="btn-small" id="exportTimestampsBtn">Export</button>
              <button class="btn-small" id="clearTimestampsBtn">Clear All</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Disconnect Screen -->
    <section id="disconnectPanel" class="main-panel hidden">
      <div class="modules">
        <div class="module"><h3>EEG</h3><button class="btn-small">Disconnect</button></div>
        <div class="module"><h3>Vitals</h3><button class="btn-small">Disconnect</button></div>
        <div class="module disabled"><h3>NIRS</h3><p>Coming Soon</p></div>
      </div>
    </section>
  </main>

  <!-- JS toggling logic -->
  <script>
    const buttons = {
      connect: document.getElementById("connectBtn"),
      visualize: document.getElementById("visualizeBtn"),
      disconnect: document.getElementById("disconnectBtn"),
    };

    const panels = {
      main: document.getElementById("mainPanel"),
      connect: document.getElementById("connectPanel"),
      visualize: document.getElementById("visualizePanel"),
      disconnect: document.getElementById("disconnectPanel"),
    };

    let active = "main";
    let currentView = "realtime"; // "realtime" or "trends"
    let vitalsTimeOffset = 0.0; // Time offset for scrolling through vitals data
    let eegTimeOffset = 0.0; // Time offset for scrolling through EEG data
    let vitalsNumericsTimeOffset = 0.0; // Time offset for scrolling through vitals numerics
    let vitalsRefreshInterval = null; // Interval for auto-refreshing vitals
    let eegRefreshInterval = null; // Interval for auto-refreshing EEG
    let vitalsNumericsRefreshInterval = null; // Interval for auto-refreshing vitals numerics
    const VITALS_REFRESH_RATE = 1000; // Refresh every 1 second
    const EEG_REFRESH_RATE = 1000; // Refresh every 1 second
    const VITALS_NUMERICS_REFRESH_RATE = 1000; // Refresh every 1 second
    const VITALS_SCROLL_STEP = 0.5; // Advance by 0.5 seconds each refresh
    const EEG_SCROLL_STEP = 0.5; // Advance by 0.5 seconds each refresh
    const VITALS_NUMERICS_SCROLL_STEP = 1.0; // Advance by 1.0 seconds each refresh (slower for numerics)
    
    // Track uploaded files
    let uploadedFiles = {
      eeg: false,
      vitalsWaves: false,
      vitalsNumerics: false
    };

    function showPanel(target) {
      Object.values(panels).forEach(p => p.classList.add("hidden"));
      panels[target].classList.remove("hidden");

      buttons.connect.textContent = "Connect";
      buttons.visualize.textContent = "Visualize";
      buttons.disconnect.textContent = "Disconnect";

      if (target !== "main") buttons[target].textContent = "← Back";
      active = target;
    }

    buttons.connect.onclick = () =>
      showPanel(active === "connect" ? "main" : "connect");
    buttons.disconnect.onclick = () =>
      showPanel(active === "disconnect" ? "main" : "disconnect");

    // Function to stop auto-refresh
    function stopVitalsAutoRefresh() {
      if (vitalsRefreshInterval) {
        clearInterval(vitalsRefreshInterval);
        vitalsRefreshInterval = null;
      }
    }

    // Canvas rendering for vitals waveforms
    const vitalsCanvas = document.getElementById("vitalsCanvas");
    const vitalsCtx = vitalsCanvas ? vitalsCanvas.getContext("2d") : null;
    const vitalsLoadingDiv = document.getElementById("vitalsLoading");

    // Canvas rendering for vitals trends (numerics)
    const vitalsTrendsCanvas = document.getElementById("vitalsTrendsCanvas");
    const vitalsTrendsCtx = vitalsTrendsCanvas ? vitalsTrendsCanvas.getContext("2d") : null;
    const vitalsTrendsLoadingDiv = document.getElementById("vitalsTrendsLoading");

    // Canvas rendering for EEG monitor
    const eegCanvas = document.getElementById("eegCanvas");
    const eegCtx = eegCanvas ? eegCanvas.getContext("2d") : null;
    const eegLoadingDiv = document.getElementById("eegLoading");

    // High-DPI canvas setup function
    function setupHighDPICanvas(canvas, width, height) {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return ctx;
    }

    // Set fixed canvas sizes
    if (vitalsCanvas) {
      setupHighDPICanvas(vitalsCanvas, 800, 500);
    }

    if (vitalsTrendsCanvas) {
      setupHighDPICanvas(vitalsTrendsCanvas, 800, 400);
    }

    if (eegCanvas) {
      setupHighDPICanvas(eegCanvas, 800, 400);
    }
    
    // Scientific plotting color scheme (white background, crisp lines)
    const colors = {
      background: '#ffffff',
      grid: '#e5e5e5',
      hr: '#0066cc',
      spo2: '#009900',
      rr: '#cc6600',
      map: '#9900cc',
      text: '#000000',
      axis: '#333333',
      marker: '#cc0000'
    };
    
    // Function to render scientific multi-series chart for vitals
    function renderVitalsMonitor(data) {
      if (!vitalsCanvas) return;

      // Use waveforms_series for plotting
      const waveformsSeries = data.waveforms_series || {};
      if (!data || Object.keys(waveformsSeries).length === 0) {
        if (vitalsLoadingDiv) {
          vitalsLoadingDiv.textContent = "No vitals data available. Please upload waves file.";
          vitalsLoadingDiv.classList.remove('hidden');
        }
        return;
      }

      // Hide loading
      vitalsLoadingDiv.classList.add('hidden');

      // Get context and dimensions (use fixed dimensions)
      const ctx = vitalsCanvas.getContext('2d');
      if (!ctx) return;

      const width = 800;
      const height = 500;
      const leftPadding = 80;
      const rightPadding = 40;
      const topPadding = 40;
      const bottomPadding = 60;
      const plotWidth = width - leftPadding - rightPadding;
      const plotHeight = height - topPadding - bottomPadding;

      // Clear canvas with anti-aliasing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      const windowDuration = data.window_duration || 10.0;
      
      // Map waveform keys to colors and labels (using waveforms from waves file)
      const vitalsConfig = {
        'ecg': { color: colors.hr, label: 'ECG', unit: 'mV', yAxis: 'left' },
        'abp': { color: colors.map, label: 'ABP', unit: 'mmHg', yAxis: 'right' },
        'pleth': { color: colors.spo2, label: 'Pleth', unit: 'a.u.', yAxis: 'left' },
        'resp': { color: colors.rr, label: 'Resp', unit: 'a.u.', yAxis: 'right' }
      };
      
      // Get available waveforms (limit to 3)
      const availableVitals = [];
      for (const [key, config] of Object.entries(vitalsConfig)) {
        if (waveformsSeries[key]) {
          availableVitals.push({ key, ...config, data: waveformsSeries[key] });
        }
      }
      
      if (availableVitals.length === 0) return;
      
      // Limit to 3 vitals max
      const vitalsToPlot = availableVitals.slice(0, 3);
      
      // Calculate y-scales for each vital (waveform)
      vitalsToPlot.forEach(vital => {
        const values = vital.data.values;
        vital.min = Math.min(...values);
        vital.max = Math.max(...values);
        vital.range = vital.max - vital.min || 1;
      });
      
      // Draw grid (light gray)
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        ctx.beginPath();
        ctx.moveTo(x, topPadding);
        ctx.lineTo(x, topPadding + plotHeight);
        ctx.stroke();
      }
      for (let i = 0; i <= 5; i++) {
        const y = topPadding + (plotHeight / 5) * i;
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(leftPadding + plotWidth, y);
        ctx.stroke();
      }
      
      // Separate vitals by y-axis for labeling
      const leftVitals = vitalsToPlot.filter(v => v.yAxis === 'left');
      const rightVitals = vitalsToPlot.filter(v => v.yAxis === 'right');
      
      // Draw axes
      ctx.strokeStyle = colors.axis;
      ctx.lineWidth = 2;
      // X-axis
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding + plotHeight);
      ctx.lineTo(leftPadding + plotWidth, topPadding + plotHeight);
      ctx.stroke();
      // Y-axis (left)
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding);
      ctx.lineTo(leftPadding, topPadding + plotHeight);
      ctx.stroke();
      // Y-axis (right)
      ctx.beginPath();
      ctx.moveTo(leftPadding + plotWidth, topPadding);
      ctx.lineTo(leftPadding + plotWidth, topPadding + plotHeight);
      ctx.stroke();
      
      // Draw each vital series (normalized to 0-1 for proper scaling)
      vitalsToPlot.forEach((vital, idx) => {
        const { time, values } = vital.data;
        if (!time || !values || time.length === 0) return;
        
        // Normalize values to 0-1 range
        const normalizedValues = values.map(v => (v - vital.min) / vital.range);
        
        // Draw line with improved quality
        ctx.strokeStyle = vital.color;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
        const yOffset = topPadding + plotHeight;
        
        for (let i = 0; i < time.length; i++) {
          const x = leftPadding + (time[i] / windowDuration) * plotWidth;
          const y = yOffset - normalizedValues[i] * plotHeight;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Draw markers at notable points (detect significant changes)
        ctx.fillStyle = colors.marker;
        for (let i = 1; i < values.length - 1; i++) {
          const change = Math.abs(normalizedValues[i] - normalizedValues[i-1]);
          if (change > 0.15) { // Significant change (>15% of range)
            const x = leftPadding + (time[i] / windowDuration) * plotWidth;
            const y = yOffset - normalizedValues[i] * plotHeight;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        
        // Draw legend
        ctx.fillStyle = vital.color;
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${vital.label} (${vital.unit})`, leftPadding + 5, topPadding - 20 + idx * 20);
      });

      // Draw X-axis labels (Time)
      ctx.fillStyle = colors.text;
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        const timeValue = (i / 10) * windowDuration;
        ctx.fillText(timeValue.toFixed(1), x, topPadding + plotHeight + 10);
      }
      ctx.fillText('Time (s)', leftPadding + plotWidth / 2, topPadding + plotHeight + 30);
      
      // Draw Y-axis labels (left)
      if (leftVitals.length > 0) {
        const vital = leftVitals[0];
        const tickCount = 6;
        ctx.fillStyle = colors.text;
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= tickCount; i++) {
          const value = vital.min + (vital.range / tickCount) * i;
          const y = topPadding + plotHeight - (i / tickCount) * plotHeight;
          ctx.fillText(value.toFixed(0), leftPadding - 10, y);
        }
        ctx.save();
        ctx.translate(15, topPadding + plotHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText(`${leftVitals.map(v => v.label).join(', ')}`, 0, 0);
        ctx.restore();
      }
      
      // Draw Y-axis labels (right)
      if (rightVitals.length > 0) {
        const vital = rightVitals[0];
        const tickCount = 6;
        ctx.fillStyle = colors.text;
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        for (let i = 0; i <= tickCount; i++) {
          const value = vital.min + (vital.range / tickCount) * i;
          const y = topPadding + plotHeight - (i / tickCount) * plotHeight;
          ctx.fillText(value.toFixed(0), leftPadding + plotWidth + 10, y);
        }
        ctx.save();
        ctx.translate(leftPadding + plotWidth - 15, topPadding + plotHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText(`${rightVitals.map(v => v.label).join(', ')}`, 0, 0);
        ctx.restore();
      }
    }
    
    // Function to render vitals numerics chart (EEG-style with separate channels)
    function renderVitalsNumerics(data) {
      if (!vitalsTrendsCanvas) return;

      if (!data || !data.numerics) {
        if (!data || Object.keys(data.numerics || {}).length === 0) {
          if (vitalsTrendsLoadingDiv) {
            vitalsTrendsLoadingDiv.textContent = "No vitals numerics data available. Please upload numerics file.";
            vitalsTrendsLoadingDiv.classList.remove('hidden');
          }
          return;
        }
      }

      // Hide loading
      vitalsTrendsLoadingDiv.classList.add('hidden');

      // Get context and dimensions (use fixed dimensions)
      const ctx = vitalsTrendsCanvas.getContext('2d');
      if (!ctx) return;

      const width = 800;
      const height = 400;
      const leftPadding = 80;
      const rightPadding = 40;
      const topPadding = 40;
      const bottomPadding = 60;
      const plotWidth = width - leftPadding - rightPadding;
      const plotHeight = height - topPadding - bottomPadding;

      // Clear canvas with anti-aliasing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);

      const numerics = data.numerics || {};
      const windowDuration = data.window_duration || 60.0;
      const numericKeys = Object.keys(numerics);

      if (numericKeys.length === 0) return;

      // Limit to 3 numerics
      const numericsToPlot = numericKeys.slice(0, 3);
      const numNumerics = numericsToPlot.length;

      // Calculate y-scales for each numeric
      const numericConfigs = numericsToPlot.map((key, idx) => {
        const numericData = numerics[key];
        const values = numericData.values;
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;

        // Each numeric gets its own vertical space
        const numericHeight = plotHeight / numNumerics;
        const yOffset = topPadding + (idx * numericHeight);

        return {
          key,
          data: numericData,
          min,
          max,
          range,
          yOffset,
          numericHeight
        };
      });

      // Draw grid
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        ctx.beginPath();
        ctx.moveTo(x, topPadding);
        ctx.lineTo(x, topPadding + plotHeight);
        ctx.stroke();
      }

      // Draw axes
      ctx.strokeStyle = colors.axis;
      ctx.lineWidth = 2;
      // X-axis
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding + plotHeight);
      ctx.lineTo(leftPadding + plotWidth, topPadding + plotHeight);
      ctx.stroke();
      // Y-axis
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding);
      ctx.lineTo(leftPadding, topPadding + plotHeight);
      ctx.stroke();

      // Draw each numeric series
      const numericColors = {'hr': colors.hr, 'spo2': colors.spo2, 'map': colors.map};
      numericConfigs.forEach((config, idx) => {
        const { time, values } = config.data;
        if (!time || !values || time.length === 0) return;

        // Normalize values to 0-1 range
        const normalizedValues = values.map(v => (v - config.min) / config.range);

        // Draw line with improved quality
        const color = numericColors[config.key] || colors.hr;
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        const yCenter = config.yOffset + config.numericHeight / 2;

        for (let i = 0; i < time.length; i++) {
          const x = leftPadding + (time[i] / windowDuration) * plotWidth;
          // Scale normalized values to numeric height, centered
          const y = yCenter - (normalizedValues[i] - 0.5) * config.numericHeight * 0.8;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.stroke();

        // Draw data points (circles) with better quality
        ctx.fillStyle = color;
        for (let i = 0; i < time.length; i++) {
          const x = leftPadding + (time[i] / windowDuration) * plotWidth;
          const y = yCenter - (normalizedValues[i] - 0.5) * config.numericHeight * 0.8;
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, 2 * Math.PI);
          ctx.fill();
        }

        // Draw label with unit and current value
        const currentValue = values[values.length - 1].toFixed(1);
        ctx.fillStyle = color;
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          `${config.data.label}: ${currentValue} ${config.data.unit}`,
          leftPadding + 5,
          config.yOffset + 15
        );

        // Draw y-axis scale for this numeric
        ctx.fillStyle = colors.text;
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(config.max.toFixed(0), leftPadding - 5, config.yOffset + 5);
        ctx.fillText(config.min.toFixed(0), leftPadding - 5, config.yOffset + config.numericHeight - 5);

        // Draw channel separator
        if (idx < numNumerics - 1) {
          ctx.strokeStyle = colors.grid;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(leftPadding, config.yOffset + config.numericHeight);
          ctx.lineTo(leftPadding + plotWidth, config.yOffset + config.numericHeight);
          ctx.stroke();
        }
      });

      // Draw X-axis labels (Time)
      ctx.fillStyle = colors.text;
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        const timeValue = (i / 10) * windowDuration;
        ctx.fillText(timeValue.toFixed(1), x, topPadding + plotHeight + 10);
      }
      ctx.fillText('Time (s)', leftPadding + plotWidth / 2, topPadding + plotHeight + 30);
    }

    // Function to render EEG chart
    function renderEEGMonitor(data) {
      if (!eegCanvas) return;

      if (!data || !data.channels) {
        if (!data || Object.keys(data.channels || {}).length === 0) {
          if (eegLoadingDiv) {
            eegLoadingDiv.textContent = "No EEG data available. Please upload EEG file.";
            eegLoadingDiv.classList.remove('hidden');
          }
          return;
        }
      }

      // Hide loading
      eegLoadingDiv.classList.add('hidden');

      // Get context and dimensions (use fixed dimensions)
      const ctx = eegCanvas.getContext('2d');
      if (!ctx) return;

      const width = 800;
      const height = 400;
      const leftPadding = 80;
      const rightPadding = 40;
      const topPadding = 40;
      const bottomPadding = 60;
      const plotWidth = width - leftPadding - rightPadding;
      const plotHeight = height - topPadding - bottomPadding;

      // Clear canvas with anti-aliasing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      const channels = data.channels || {};
      const windowDuration = data.window_duration || 10.0;
      const channelKeys = Object.keys(channels);
      
      if (channelKeys.length === 0) return;
      
      // Limit to 8 channels
      const channelsToPlot = channelKeys.slice(0, 8);
      const numChannels = channelsToPlot.length;
      
      // Calculate y-scales for each channel
      const channelConfigs = channelsToPlot.map((key, idx) => {
        const channelData = channels[key];
        const values = channelData.values;
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;
        
        // Each channel gets its own vertical space
        const channelHeight = plotHeight / numChannels;
        const yOffset = topPadding + (idx * channelHeight);
        
        return {
          key,
          data: channelData,
          min,
          max,
          range,
          yOffset,
          channelHeight
        };
      });
      
      // Draw grid
      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        ctx.beginPath();
        ctx.moveTo(x, topPadding);
        ctx.lineTo(x, topPadding + plotHeight);
        ctx.stroke();
      }

      // Draw axes
      ctx.strokeStyle = colors.axis;
      ctx.lineWidth = 2;
      // X-axis
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding + plotHeight);
      ctx.lineTo(leftPadding + plotWidth, topPadding + plotHeight);
      ctx.stroke();
      // Y-axis
      ctx.beginPath();
      ctx.moveTo(leftPadding, topPadding);
      ctx.lineTo(leftPadding, topPadding + plotHeight);
      ctx.stroke();
      
      // Draw each channel
      const channelColors = ['#0066cc', '#009900', '#cc6600', '#9900cc', '#ff0066', '#00ffff', '#ff9900', '#cc00ff'];
      channelConfigs.forEach((config, idx) => {
        const { time, values } = config.data;
        if (!time || !values || time.length === 0) return;
        
        // Normalize values to 0-1 range
        const normalizedValues = values.map(v => (v - config.min) / config.range);
        
        // Draw line with improved quality
        ctx.strokeStyle = channelColors[idx % channelColors.length];
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();

        const yCenter = config.yOffset + config.channelHeight / 2;

        for (let i = 0; i < time.length; i++) {
          const x = leftPadding + (time[i] / windowDuration) * plotWidth;
          // Scale normalized values to channel height, centered
          const y = yCenter - (normalizedValues[i] - 0.5) * config.channelHeight * 0.8;

          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.stroke();

        // Draw channel label
        ctx.fillStyle = channelColors[idx % channelColors.length];
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(config.key, leftPadding + 5, config.yOffset + config.channelHeight / 2);

        // Draw channel separator
        if (idx < numChannels - 1) {
          ctx.strokeStyle = colors.grid;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(leftPadding, config.yOffset + config.channelHeight);
          ctx.lineTo(leftPadding + plotWidth, config.yOffset + config.channelHeight);
          ctx.stroke();
        }
      });

      // Draw X-axis labels (Time)
      ctx.fillStyle = colors.text;
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for (let i = 0; i <= 10; i++) {
        const x = leftPadding + (plotWidth / 10) * i;
        const timeValue = (i / 10) * windowDuration;
        ctx.fillText(timeValue.toFixed(1), x, topPadding + plotHeight + 10);
      }
      ctx.fillText('Time (s)', leftPadding + plotWidth / 2, topPadding + plotHeight + 30);
    }
    
    // Function to fetch and render vitals data
    async function updateVitalsMonitor(timeOffset) {
      try {
        const base = "http://127.0.0.1:8000";
        const response = await fetch(`${base}/api/vitals/live/data?time_offset=${timeOffset}`);
        
        if (!response.ok) throw new Error('Failed to fetch vitals data');
        
        const data = await response.json();
        renderVitalsMonitor(data);
      } catch (error) {
        console.error('Error updating vitals monitor:', error);
        vitalsLoadingDiv.textContent = `Error: ${error.message}`;
        vitalsLoadingDiv.classList.remove('hidden');
      }
    }
    
    // Function to fetch and render vitals numerics data
    async function updateVitalsNumerics(timeOffset) {
      try {
        const base = "http://127.0.0.1:8000";
        const response = await fetch(`${base}/api/vitals/numerics/data?time_offset=${timeOffset}`);

        if (!response.ok) throw new Error('Failed to fetch vitals numerics data');

        const data = await response.json();
        renderVitalsNumerics(data);
      } catch (error) {
        console.error('Error updating vitals numerics:', error);
        vitalsLoadingDiv.textContent = `Error: ${error.message}`;
        vitalsLoadingDiv.classList.remove('hidden');
      }
    }

    // Function to fetch and render EEG data
    async function updateEEGMonitor(timeOffset) {
      try {
        const base = "http://127.0.0.1:8000";
        const response = await fetch(`${base}/api/graphs/eeg/live/data?time_offset=${timeOffset}`);
        
        if (!response.ok) throw new Error('Failed to fetch EEG data');
        
        const data = await response.json();
        renderEEGMonitor(data);
      } catch (error) {
        console.error('Error updating EEG monitor:', error);
        eegLoadingDiv.textContent = `Error: ${error.message}`;
        eegLoadingDiv.classList.remove('hidden');
      }
    }
    
    // Function to stop auto-refresh for EEG
    function stopEEGAutoRefresh() {
      if (eegRefreshInterval) {
        clearInterval(eegRefreshInterval);
        eegRefreshInterval = null;
      }
    }
    
    // Function to start auto-refresh for EEG monitor
    function startEEGAutoRefresh() {
      stopEEGAutoRefresh(); // Clear any existing interval
      
      // Reset time offset when starting
      eegTimeOffset = 0.0;
      
      // Load initial frame immediately
      updateEEGMonitor(eegTimeOffset);
      eegTimeOffset += EEG_SCROLL_STEP;
      
      // Set up interval to refresh EEG display
      eegRefreshInterval = setInterval(() => {
        updateEEGMonitor(eegTimeOffset);
        eegTimeOffset += EEG_SCROLL_STEP;
        
        // Reset to beginning after 1 hour (3600 seconds)
        if (eegTimeOffset > 3600) {
          eegTimeOffset = 0.0;
        }
      }, EEG_REFRESH_RATE);
    }
    
    // Function to start auto-refresh for vitals monitor
    function startVitalsAutoRefresh() {
      stopVitalsAutoRefresh(); // Clear any existing interval

      // Reset time offset when starting
      vitalsTimeOffset = 0.0;

      // Load initial frame immediately
      updateVitalsMonitor(vitalsTimeOffset);
      vitalsTimeOffset += VITALS_SCROLL_STEP;

      // Set up interval to refresh vitals display
      vitalsRefreshInterval = setInterval(() => {
        updateVitalsMonitor(vitalsTimeOffset);
        vitalsTimeOffset += VITALS_SCROLL_STEP;

        // Reset to beginning after 1 hour (3600 seconds)
        if (vitalsTimeOffset > 3600) {
          vitalsTimeOffset = 0.0;
        }
      }, VITALS_REFRESH_RATE);
    }

    // Function to stop auto-refresh for vitals numerics
    function stopVitalsNumericsAutoRefresh() {
      if (vitalsNumericsRefreshInterval) {
        clearInterval(vitalsNumericsRefreshInterval);
        vitalsNumericsRefreshInterval = null;
      }
    }

    // Function to start auto-refresh for vitals numerics monitor
    function startVitalsNumericsAutoRefresh() {
      stopVitalsNumericsAutoRefresh(); // Clear any existing interval

      // Reset time offset when starting
      vitalsNumericsTimeOffset = 0.0;

      // Load initial frame immediately
      updateVitalsNumerics(vitalsNumericsTimeOffset);
      vitalsNumericsTimeOffset += VITALS_NUMERICS_SCROLL_STEP;

      // Set up interval to refresh vitals numerics display
      vitalsNumericsRefreshInterval = setInterval(() => {
        updateVitalsNumerics(vitalsNumericsTimeOffset);
        vitalsNumericsTimeOffset += VITALS_NUMERICS_SCROLL_STEP;

        // Reset to beginning after 1 hour (3600 seconds)
        if (vitalsNumericsTimeOffset > 3600) {
          vitalsNumericsTimeOffset = 0.0;
        }
      }, VITALS_NUMERICS_REFRESH_RATE);
    }

    // Function to update displayed graphs based on current view
    function updateGraphs() {
      const base = "http://127.0.0.1:8000";
      
      if (currentView === "realtime") {
        // Start auto-refresh for EEG if file is uploaded
        if (uploadedFiles.eeg) {
          startEEGAutoRefresh();
        } else {
          stopEEGAutoRefresh();
          eegTimeOffset = 0.0;
        }

        // Start auto-refresh for vitals waveforms if waves file is uploaded
        if (uploadedFiles.vitalsWaves) {
          startVitalsAutoRefresh();
        } else {
          stopVitalsAutoRefresh();
          vitalsTimeOffset = 0.0;
        }

        // Start auto-refresh for vitals numerics if numerics file is uploaded
        if (uploadedFiles.vitalsNumerics) {
          startVitalsNumericsAutoRefresh();
        } else {
          stopVitalsNumericsAutoRefresh();
          vitalsNumericsTimeOffset = 0.0;
        }
      } else {
        // Stop auto-refresh when switching away from realtime
        stopEEGAutoRefresh();
        stopVitalsAutoRefresh();
        stopVitalsNumericsAutoRefresh();
        eegTimeOffset = 0.0;
        vitalsTimeOffset = 0.0;
        vitalsNumericsTimeOffset = 0.0;
        
        // Show trend images
        if (eegCanvas) eegCanvas.style.display = 'none';
        if (vitalsCanvas) vitalsCanvas.style.display = 'none';
        if (eegLoadingDiv) eegLoadingDiv.style.display = 'none';
        if (vitalsLoadingDiv) vitalsLoadingDiv.style.display = 'none';
        
        // Load EEG trend image
        const eegBox = document.getElementById("eegBox");
        if (eegBox) {
          eegBox.innerHTML = '<div style="text-align: center; padding: 10px; color: #aaa;">Loading...</div>';
          fetch(base + "/api/graphs/eeg/trend")
            .then(response => {
              if (!response.ok) throw new Error('Network response was not ok');
              return response.blob();
            })
            .then(blob => {
              const imageUrl = URL.createObjectURL(blob);
              eegBox.innerHTML = `<img src="${imageUrl}" style="max-width: 100%; height: auto; display: block;" alt="EEG Trend Graph" />`;
            })
            .catch(error => {
              eegBox.innerHTML = `<div style="text-align: center; padding: 10px; color: #ff6b6b;">Error loading image: ${error.message}</div>`;
            });
        }
        
        // Load vitals trend image
        const imageContainer = document.getElementById("vitalsImageContainer");
        if (imageContainer) {
          imageContainer.style.display = 'block';
          imageContainer.innerHTML = '<div style="text-align: center; padding: 10px; color: #aaa;">Loading...</div>';
          fetch(base + "/api/vitals/trend")
            .then(response => {
              if (!response.ok) throw new Error('Network response was not ok');
              return response.blob();
            })
            .then(blob => {
              const imageUrl = URL.createObjectURL(blob);
              imageContainer.innerHTML = `<img src="${imageUrl}" style="max-width: 100%; height: auto; display: block;" alt="Trend Graph" />`;
            })
            .catch(error => {
              imageContainer.innerHTML = `<div style="text-align: center; padding: 10px; color: #ff6b6b;">Error loading image: ${error.message}</div>`;
            });
        }
      }
    }

    // Function to upload a file
    async function uploadFile(fileInput, uploadUrl, statusElement, fileType) {
      const file = fileInput.files[0];
      if (!file) {
        statusElement.textContent = "Please select a file";
        statusElement.style.color = "#ff6b6b";
        return;
      }

      const formData = new FormData();
      formData.append("file", file);

      statusElement.textContent = "Uploading...";
      statusElement.style.color = "#aaa";

      try {
        const response = await fetch(uploadUrl, {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          throw new Error(`Upload failed: ${response.statusText}`);
        }

        const result = await response.json();
        statusElement.textContent = `✓ ${file.name}`;
        statusElement.style.color = "#4a90e2";
        
        // Track uploaded file
        uploadedFiles[fileType] = true;
        
        // Automatically update graphs after successful upload
        updateGraphs();
      } catch (error) {
        statusElement.textContent = `✗ Error: ${error.message}`;
        statusElement.style.color = "#ff6b6b";
        uploadedFiles[fileType] = false;
      }
    }

    // Set up file upload handlers
    document.getElementById("uploadEEG").onclick = () => {
      const fileInput = document.getElementById("eegFile");
      uploadFile(fileInput, "http://127.0.0.1:8000/api/graphs/eeg/upload", 
                 document.getElementById("eegStatus"), "eeg");
    };

    document.getElementById("uploadVitalsWaves").onclick = () => {
      const fileInput = document.getElementById("vitalsWavesFile");
      uploadFile(fileInput, "http://127.0.0.1:8000/api/vitals/waves/upload", 
                 document.getElementById("vitalsWavesStatus"), "vitalsWaves");
    };

    document.getElementById("uploadVitalsNumerics").onclick = () => {
      const fileInput = document.getElementById("vitalsNumericsFile");
      uploadFile(fileInput, "http://127.0.0.1:8000/api/vitals/numerics/upload",
                 document.getElementById("vitalsNumericsStatus"), "vitalsNumerics");
    };

    // Clear button handlers
    document.getElementById("clearEEGBtn").onclick = async () => {
      // Stop auto-refresh
      stopEEGAutoRefresh();

      // Reset time offset
      eegTimeOffset = 0.0;

      // Clear uploaded file tracking
      uploadedFiles.eeg = false;

      // Call backend to delete the file
      try {
        await fetch("http://127.0.0.1:8000/api/graphs/eeg/clear", {
          method: "DELETE"
        });
      } catch (error) {
        console.error("Error clearing EEG file:", error);
      }

      // Clear file input
      const fileInput = document.getElementById("eegFile");
      if (fileInput) fileInput.value = "";

      // Clear status message
      const statusSpan = document.getElementById("eegStatus");
      if (statusSpan) statusSpan.textContent = "";

      // Clear canvas
      if (eegCanvas) {
        const ctx = eegCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, eegCanvas.width, eegCanvas.height);
        }
      }

      // Show loading message
      if (eegLoadingDiv) {
        eegLoadingDiv.textContent = "Select files to view...";
        eegLoadingDiv.classList.remove('hidden');
      }
    };

    document.getElementById("clearVitalsWavesBtn").onclick = async () => {
      // Stop auto-refresh
      stopVitalsAutoRefresh();

      // Reset time offset
      vitalsTimeOffset = 0.0;

      // Clear uploaded file tracking
      uploadedFiles.vitalsWaves = false;

      // Call backend to delete the file
      try {
        await fetch("http://127.0.0.1:8000/api/vitals/waves/clear", {
          method: "DELETE"
        });
      } catch (error) {
        console.error("Error clearing vitals waves file:", error);
      }

      // Clear file input
      const fileInput = document.getElementById("vitalsWavesFile");
      if (fileInput) fileInput.value = "";

      // Clear status message
      const statusSpan = document.getElementById("vitalsWavesStatus");
      if (statusSpan) statusSpan.textContent = "";

      // Clear canvas
      if (vitalsCanvas) {
        const ctx = vitalsCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, vitalsCanvas.width, vitalsCanvas.height);
        }
      }

      // Show loading message
      if (vitalsLoadingDiv) {
        vitalsLoadingDiv.textContent = "Select files to view...";
        vitalsLoadingDiv.classList.remove('hidden');
      }
    };

    document.getElementById("clearVitalsNumericsBtn").onclick = async () => {
      // Stop auto-refresh
      stopVitalsNumericsAutoRefresh();

      // Reset time offset
      vitalsNumericsTimeOffset = 0.0;

      // Clear uploaded file tracking
      uploadedFiles.vitalsNumerics = false;

      // Call backend to delete the file
      try {
        await fetch("http://127.0.0.1:8000/api/vitals/numerics/clear", {
          method: "DELETE"
        });
      } catch (error) {
        console.error("Error clearing vitals numerics file:", error);
      }

      // Clear file input
      const fileInput = document.getElementById("vitalsNumericsFile");
      if (fileInput) fileInput.value = "";

      // Clear status message
      const statusSpan = document.getElementById("vitalsNumericsStatus");
      if (statusSpan) statusSpan.textContent = "";

      // Clear canvas
      if (vitalsTrendsCanvas) {
        const ctx = vitalsTrendsCanvas.getContext('2d');
        if (ctx) {
          ctx.clearRect(0, 0, vitalsTrendsCanvas.width, vitalsTrendsCanvas.height);
        }
      }

      // Show loading message
      if (vitalsTrendsLoadingDiv) {
        vitalsTrendsLoadingDiv.textContent = "Select files to view...";
        vitalsTrendsLoadingDiv.classList.remove('hidden');
      }
    };

    // Tab switching functionality
    const tabs = document.querySelectorAll(".tab");
    tabs.forEach((tab, index) => {
      tab.onclick = () => {
        // Remove active class from all tabs
        tabs.forEach(t => t.classList.remove("active"));
        // Add active class to clicked tab
        tab.classList.add("active");
        
        if (index === 0) {
          // Real Time tab
          currentView = "realtime";
          updateGraphs();
        } else if (index === 1) {
          // Trends tab
          currentView = "trends";
          updateGraphs();
        } else if (index === 2) {
          // Test Graphs tab - use current view
          updateGraphs();
        }
      };
    });

    // Show visualize panel (graphs will load when files are uploaded or tabs are clicked)
    buttons.visualize.onclick = () => {
      const wasVisualize = active === "visualize";
      showPanel(active === "visualize" ? "main" : "visualize");

      // Stop auto-refresh when leaving visualize panel
      if (wasVisualize && active === "main") {
        stopVitalsAutoRefresh();
        stopEEGAutoRefresh();
        stopVitalsNumericsAutoRefresh();
        vitalsTimeOffset = 0.0;
        eegTimeOffset = 0.0;
        vitalsNumericsTimeOffset = 0.0;
      } else if (!wasVisualize && active === "visualize") {
        // When entering visualize panel, update graphs if in realtime view
        if (currentView === "realtime") {
          updateGraphs();
        }
        // Load timestamps when entering visualize panel
        loadTimestamps();
      }
    };

    // =====================
    // TIMESTAMP FUNCTIONALITY
    // =====================

    const API_BASE = "http://127.0.0.1:8000";

    // Load and display all timestamps
    async function loadTimestamps() {
      try {
        const response = await fetch(`${API_BASE}/api/timestamps/`);
        if (!response.ok) throw new Error('Failed to load timestamps');

        const data = await response.json();
        renderTimestampTable(data.timestamps);
      } catch (error) {
        console.error('Error loading timestamps:', error);
      }
    }

    // Render timestamp table
    function renderTimestampTable(timestamps) {
      const tableBody = document.getElementById('timestampTableBody');
      if (!tableBody) return;

      if (timestamps.length === 0) {
        tableBody.innerHTML = '<div class="timestamp-empty">No timestamps yet. Add one below.</div>';
        return;
      }

      // Sort by time offset
      timestamps.sort((a, b) => a.time_offset - b.time_offset);

      tableBody.innerHTML = timestamps.map(ts => `
        <div class="timestamp-row" data-id="${ts.id}">
          <span class="timestamp-time">${ts.time_offset.toFixed(1)}s</span>
          <span class="timestamp-desc">${escapeHtml(ts.description)}</span>
          <span class="timestamp-actions">
            <button class="btn-tiny" onclick="deleteTimestamp(${ts.id})">×</button>
          </span>
        </div>
      `).join('');
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Add a new timestamp
    async function addTimestamp(timeOffset, description) {
      if (!description.trim()) {
        alert('Please enter a description');
        return;
      }

      try {
        const response = await fetch(`${API_BASE}/api/timestamps/`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            time_offset: parseFloat(timeOffset),
            description: description.trim()
          })
        });

        if (!response.ok) throw new Error('Failed to add timestamp');

        // Reload timestamps
        loadTimestamps();

        // Clear inputs
        document.getElementById('timestampTimeInput').value = '';
        document.getElementById('timestampDescInput').value = '';
      } catch (error) {
        console.error('Error adding timestamp:', error);
        alert('Failed to add timestamp: ' + error.message);
      }
    }

    // Delete a timestamp
    async function deleteTimestamp(id) {
      try {
        const response = await fetch(`${API_BASE}/api/timestamps/${id}`, {
          method: 'DELETE'
        });

        if (!response.ok) throw new Error('Failed to delete timestamp');

        // Reload timestamps
        loadTimestamps();
      } catch (error) {
        console.error('Error deleting timestamp:', error);
        alert('Failed to delete timestamp: ' + error.message);
      }
    }

    // Clear all timestamps
    async function clearAllTimestamps() {
      if (!confirm('Are you sure you want to clear all timestamps?')) return;

      try {
        const response = await fetch(`${API_BASE}/api/timestamps/`, {
          method: 'DELETE'
        });

        if (!response.ok) throw new Error('Failed to clear timestamps');

        // Reload timestamps
        loadTimestamps();
      } catch (error) {
        console.error('Error clearing timestamps:', error);
        alert('Failed to clear timestamps: ' + error.message);
      }
    }

    // Export timestamps as JSON file
    async function exportTimestamps() {
      try {
        const response = await fetch(`${API_BASE}/api/timestamps/export`);

        if (!response.ok) {
          const data = await response.json();
          alert(data.message || 'Failed to export timestamps');
          return;
        }

        // Download the file
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'timestamps.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Error exporting timestamps:', error);
        alert('Failed to export timestamps: ' + error.message);
      }
    }

    // Get current time offset based on which monitor is running
    function getCurrentTimeOffset() {
      // Priority: EEG > Vitals Waves > Vitals Numerics
      if (uploadedFiles.eeg && eegTimeOffset > 0) {
        return eegTimeOffset;
      } else if (uploadedFiles.vitalsWaves && vitalsTimeOffset > 0) {
        return vitalsTimeOffset;
      } else if (uploadedFiles.vitalsNumerics && vitalsNumericsTimeOffset > 0) {
        return vitalsNumericsTimeOffset;
      }
      return 0;
    }

    // Set up timestamp button handlers
    document.getElementById('addTimestampBtn').onclick = () => {
      const timeInput = document.getElementById('timestampTimeInput');
      const descInput = document.getElementById('timestampDescInput');
      const timeValue = parseFloat(timeInput.value) || 0;
      addTimestamp(timeValue, descInput.value);
    };

    document.getElementById('markCurrentTimeBtn').onclick = () => {
      const currentTime = getCurrentTimeOffset();
      document.getElementById('timestampTimeInput').value = currentTime.toFixed(1);
      document.getElementById('timestampDescInput').focus();
    };

    document.getElementById('exportTimestampsBtn').onclick = exportTimestamps;
    document.getElementById('clearTimestampsBtn').onclick = clearAllTimestamps;

    // Allow Enter key to add timestamp
    document.getElementById('timestampDescInput').onkeypress = (e) => {
      if (e.key === 'Enter') {
        document.getElementById('addTimestampBtn').click();
      }
    };

    // Make deleteTimestamp available globally for onclick handlers
    window.deleteTimestamp = deleteTimestamp;

    // =====================
    // THRESHOLD MONITORING
    // =====================

    // Store current vitals values and thresholds
    let currentVitals = {
      hr: null,
      spo2: null,
      map: null
    };

    // Track last breach state to avoid duplicate annotations
    let lastBreachState = {
      hr: null,
      spo2: null,
      map: null
    };

    // Get threshold bounds from inputs
    function getThresholdBounds() {
      return {
        hr: {
          min: parseFloat(document.getElementById('hrMin').value) || 60,
          max: parseFloat(document.getElementById('hrMax').value) || 100
        },
        spo2: {
          min: parseFloat(document.getElementById('spo2Min').value) || 92,
          max: parseFloat(document.getElementById('spo2Max').value) || 100
        },
        map: {
          min: parseFloat(document.getElementById('mapMin').value) || 70,
          max: parseFloat(document.getElementById('mapMax').value) || 105
        }
      };
    }

    // Check threshold and return status: 'normal', 'warning', 'breach'
    function checkThreshold(value, min, max) {
      if (value === null || value === undefined) return null;

      // Warning zone is 10% of range near boundaries
      const range = max - min;
      const warningMargin = range * 0.1;

      if (value < min || value > max) {
        return 'breach';
      } else if (value < min + warningMargin || value > max - warningMargin) {
        return 'warning';
      }
      return 'normal';
    }

    // Update threshold UI for a specific vital
    function updateThresholdUI(param, value, status) {
      const valueEl = document.getElementById(`${param}Value`);
      const indicatorEl = document.getElementById(`${param}Indicator`);
      const itemEl = document.querySelector(`.threshold-item[data-param="${param}"]`);

      if (!valueEl || !indicatorEl || !itemEl) return;

      // Update value display
      if (value !== null && value !== undefined) {
        valueEl.textContent = value.toFixed(0);
      } else {
        valueEl.textContent = '--';
      }

      // Update indicator and item classes
      indicatorEl.classList.remove('normal', 'warning', 'breach');
      itemEl.classList.remove('normal', 'warning', 'breach');

      if (status) {
        indicatorEl.classList.add(status);
        itemEl.classList.add(status);
      }
    }

    // Update all threshold displays based on current vitals data
    function updateThresholdMonitor(numericsData) {
      if (!numericsData || !numericsData.numerics) {
        // No data available
        const statusEl = document.getElementById('thresholdStatus');
        if (statusEl) {
          statusEl.classList.remove('active');
          statusEl.querySelector('.status-message').textContent = 'Upload vitals numerics to enable';
        }
        return;
      }

      const numerics = numericsData.numerics;
      const bounds = getThresholdBounds();
      const autoAnnotate = document.getElementById('autoAnnotateBreaches').checked;

      // Update status to active
      const statusEl = document.getElementById('thresholdStatus');
      if (statusEl) {
        statusEl.classList.add('active');
        statusEl.querySelector('.status-message').textContent = 'Monitoring active';
      }

      // Check each vital
      ['hr', 'spo2', 'map'].forEach(param => {
        const numericData = numerics[param];
        if (numericData && numericData.values && numericData.values.length > 0) {
          // Get latest value
          const latestValue = numericData.values[numericData.values.length - 1];
          currentVitals[param] = latestValue;

          const status = checkThreshold(latestValue, bounds[param].min, bounds[param].max);
          updateThresholdUI(param, latestValue, status);

          // Auto-annotate breaches (only when transitioning to breach state)
          if (autoAnnotate && status === 'breach' && lastBreachState[param] !== 'breach') {
            const paramLabels = { hr: 'HR', spo2: 'SpO2', map: 'MAP' };
            const paramUnits = { hr: 'bpm', spo2: '%', map: 'mmHg' };
            const direction = latestValue < bounds[param].min ? 'LOW' : 'HIGH';
            const description = `${paramLabels[param]} ${direction}: ${latestValue.toFixed(0)} ${paramUnits[param]}`;

            addTimestamp(getCurrentTimeOffset(), description);
          }

          lastBreachState[param] = status;
        } else {
          currentVitals[param] = null;
          updateThresholdUI(param, null, null);
          lastBreachState[param] = null;
        }
      });
    }

    // Modified updateVitalsNumerics to also update threshold monitor
    const originalUpdateVitalsNumerics = updateVitalsNumerics;
    updateVitalsNumerics = async function(timeOffset) {
      try {
        const base = "http://127.0.0.1:8000";
        const response = await fetch(`${base}/api/vitals/numerics/data?time_offset=${timeOffset}`);

        if (!response.ok) throw new Error('Failed to fetch vitals numerics data');

        const data = await response.json();
        renderVitalsNumerics(data);

        // Update threshold monitor with the same data
        updateThresholdMonitor(data);
      } catch (error) {
        console.error('Error updating vitals numerics:', error);
        vitalsTrendsLoadingDiv.textContent = `Error: ${error.message}`;
        vitalsTrendsLoadingDiv.classList.remove('hidden');
      }
    };

    // Reset threshold monitor when clearing vitals numerics
    const originalClearVitalsNumericsHandler = document.getElementById("clearVitalsNumericsBtn").onclick;
    document.getElementById("clearVitalsNumericsBtn").onclick = async function() {
      await originalClearVitalsNumericsHandler();

      // Reset threshold monitor
      currentVitals = { hr: null, spo2: null, map: null };
      lastBreachState = { hr: null, spo2: null, map: null };

      ['hr', 'spo2', 'map'].forEach(param => {
        updateThresholdUI(param, null, null);
      });

      const statusEl = document.getElementById('thresholdStatus');
      if (statusEl) {
        statusEl.classList.remove('active');
        statusEl.querySelector('.status-message').textContent = 'Upload vitals numerics to enable';
      }
    };

    // =====================
    // EEG SPECTROGRAM
    // =====================

    // Spectrogram color map (jet-like colormap)
    function getSpectrogramColor(value, minVal, maxVal) {
      // Normalize value to 0-1 range
      const normalized = Math.max(0, Math.min(1, (value - minVal) / (maxVal - minVal)));

      // Jet colormap approximation
      let r, g, b;
      if (normalized < 0.125) {
        r = 0;
        g = 0;
        b = 0.5 + normalized * 4;
      } else if (normalized < 0.375) {
        r = 0;
        g = (normalized - 0.125) * 4;
        b = 1;
      } else if (normalized < 0.625) {
        r = (normalized - 0.375) * 4;
        g = 1;
        b = 1 - (normalized - 0.375) * 4;
      } else if (normalized < 0.875) {
        r = 1;
        g = 1 - (normalized - 0.625) * 4;
        b = 0;
      } else {
        r = 1 - (normalized - 0.875) * 2;
        g = 0;
        b = 0;
      }

      return `rgb(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    }

    // Render a single spectrogram on a canvas
    function renderSpectrogram(canvas, powerData, frequencies, times, channelName) {
      const ctx = canvas.getContext('2d');
      if (!ctx || !powerData || powerData.length === 0) return;

      const width = canvas.width;
      const height = canvas.height;

      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, width, height);

      const numFreqs = powerData.length;
      const numTimes = powerData[0].length;

      // Find min/max for color scaling
      let minPower = Infinity, maxPower = -Infinity;
      for (let f = 0; f < numFreqs; f++) {
        for (let t = 0; t < numTimes; t++) {
          const val = powerData[f][t];
          if (val < minPower) minPower = val;
          if (val > maxPower) maxPower = val;
        }
      }

      // Render spectrogram pixels
      const pixelWidth = width / numTimes;
      const pixelHeight = height / numFreqs;

      for (let f = 0; f < numFreqs; f++) {
        for (let t = 0; t < numTimes; t++) {
          const value = powerData[f][t];
          ctx.fillStyle = getSpectrogramColor(value, minPower, maxPower);
          // Flip y-axis so low frequencies are at bottom
          const y = height - (f + 1) * pixelHeight;
          ctx.fillRect(t * pixelWidth, y, pixelWidth + 1, pixelHeight + 1);
        }
      }

      // Add frequency axis labels
      ctx.fillStyle = '#fff';
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';

      // Max frequency label
      const maxFreq = frequencies[frequencies.length - 1];
      ctx.fillText(`${maxFreq.toFixed(0)} Hz`, width - 5, 12);

      // Min frequency label
      ctx.fillText(`0 Hz`, width - 5, height - 3);
    }

    // Fetch and display all spectrograms
    async function loadSpectrograms() {
      const spectrogramGrid = document.getElementById('spectrogramGrid');
      const spectrogramLoading = document.getElementById('spectrogramLoading');
      const spectrogramPanel = document.getElementById('spectrogramPanel');

      if (!spectrogramGrid || !spectrogramPanel) return;

      // Show loading
      spectrogramLoading.style.display = 'block';
      spectrogramLoading.textContent = 'Computing spectrograms...';
      spectrogramGrid.innerHTML = '';
      spectrogramGrid.appendChild(spectrogramLoading);

      try {
        const response = await fetch(`${API_BASE}/api/graphs/eeg/spectrogram?window_duration=30`);
        if (!response.ok) throw new Error('Failed to fetch spectrogram data');

        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        const channelNames = data.channel_names || [];
        const spectrograms = data.spectrograms || {};
        const frequencies = data.frequencies || [];
        const times = data.times || [];

        if (channelNames.length === 0 || Object.keys(spectrograms).length === 0) {
          spectrogramLoading.textContent = 'No EEG data available. Please upload an EEG file first.';
          return;
        }

        // Hide loading
        spectrogramLoading.style.display = 'none';

        // Create spectrogram for each channel
        channelNames.forEach(channelName => {
          const powerData = spectrograms[channelName];
          if (!powerData) return;

          // Create container
          const item = document.createElement('div');
          item.className = 'spectrogram-item';

          // Channel name header
          const header = document.createElement('h4');
          header.textContent = channelName;
          item.appendChild(header);

          // Canvas for spectrogram
          const canvas = document.createElement('canvas');
          canvas.className = 'spectrogram-canvas';
          canvas.width = 380;
          canvas.height = 120;
          item.appendChild(canvas);

          // Colorbar
          const colorbar = document.createElement('div');
          colorbar.className = 'spectrogram-colorbar';
          colorbar.innerHTML = `
            <span>Low</span>
            <div class="spectrogram-colorbar-gradient"></div>
            <span>High (dB)</span>
          `;
          item.appendChild(colorbar);

          // Time axis label
          const timeLabel = document.createElement('div');
          timeLabel.style.cssText = 'text-align: center; font-size: 0.7rem; color: #888; margin-top: 0.25rem;';
          const duration = times.length > 0 ? times[times.length - 1].toFixed(1) : '30';
          timeLabel.textContent = `Time: 0 - ${duration}s`;
          item.appendChild(timeLabel);

          spectrogramGrid.appendChild(item);

          // Render the spectrogram
          renderSpectrogram(canvas, powerData, frequencies, times, channelName);
        });

        // Show the panel
        spectrogramPanel.style.display = 'block';

      } catch (error) {
        console.error('Error loading spectrograms:', error);
        spectrogramLoading.textContent = `Error: ${error.message}`;
        spectrogramLoading.style.display = 'block';
      }
    }

    // Spectrogram button click handler
    document.getElementById('eegSpectrogramBtn').onclick = async function() {
      if (!uploadedFiles.eeg) {
        alert('Please upload an EEG file first.');
        return;
      }

      // Stop EEG auto-refresh while viewing spectrograms
      stopEEGAutoRefresh();

      // Load and display spectrograms
      await loadSpectrograms();
    };

    // Raw Traces button - switch back to live EEG view
    document.getElementById('eegRawTracesBtn').onclick = function() {
      // Hide spectrogram panel
      const spectrogramPanel = document.getElementById('spectrogramPanel');
      if (spectrogramPanel) {
        spectrogramPanel.style.display = 'none';
      }

      // Restart EEG auto-refresh if file is uploaded
      if (uploadedFiles.eeg) {
        startEEGAutoRefresh();
      }
    };

    // Close spectrogram panel button
    document.getElementById('closeSpectrogramBtn').onclick = function() {
      const spectrogramPanel = document.getElementById('spectrogramPanel');
      if (spectrogramPanel) {
        spectrogramPanel.style.display = 'none';
      }

      // Restart EEG auto-refresh if file is uploaded
      if (uploadedFiles.eeg) {
        startEEGAutoRefresh();
      }
    };

  </script>
</body>
</html>